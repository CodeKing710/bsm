#!/bin/sh

# BSM's Functions and Variables

# Vars
__cwd="$(pwd)"
__cws=""
prgroot="$HOME/.bsm"
scriptroot="$HOME/scripts"
cmds="^(create|open|rename|remove|config|sh|shell|list|version|help|update|reset|uninstall|getdeps)$"
cfg_type="^(bash|python|node|ruby|lisp|perl)$"
itemlist=""

# Output functions
error() { printf "\e[31m[ERROR]\e[0m ${1}\n" >&2; }
verbose() { [ -n "$VERBOSE" ] && printf "\e[32m[VERBOSE]\e[0m ${1}\n"; }
log() { printf "\e[36m[BSM]\e[0m ${1}\n"; }
setarg() {
  if printf "$1" | grep -q '^-' || ! echo "$1" | grep -qE "$cmds"; then
    arg="$1"
  else
    arg="$(printf "$1" | tr '[:upper:]' '[:lower:]')"
  fi
}

# Funcs
__loadcfg() {
  cfg="$prgroot/.cfg"
  editor="$(grep 'editor' "$cfg" | cut -d '=' -f2)"
  defaulttype="$(grep 'defaulttype' "$cfg" | cut -d '=' -f2)"
}
# Config vars will be set via function in-case of needing reloaded
__loadcfg

__args() {
  # Process args
  # Exit means arg list is not passed
  # Return means arg list recursively passed
  while [ -n "$1" ]; do
    setarg "$1"

    case "$arg" in
      -c | --create | create )
        shift
        setarg "$1"
        if [ -z "$arg" ]; then
          error "Missing required value: 'NAME'"
          [ "$in_shell" -eq 1 ] && return || exit 1
        fi
        __create "$@" # Rework this into a captured list until next arg or command is found
        [ "$in_shell" -eq 1 ] && return || exit 0
        ;;
      -o | --open | open )
        shift
        setarg "$1"
        __open "$arg" # Rework to use captured list
        [ "$in_shell" -eq 1 ] && return || exit 0
        ;;
      -r | --remove | remove | rm )
        shift
        setarg "$1"
        if echo "$arg" | grep -q '^-' || [ -z "$arg" ]; then
          error "Missing required value: 'NAME'"
          [ "$in_shell" -eq 1 ] && return || exit 1
        fi
        __remove "$@"
        [ "$in_shell" -eq 1 ] && return || exit 0
        ;;
      -n | --rename | rename )
        shift
        setarg "$1"
        if echo "$arg" | grep -q '^-' || [ -z "$arg" ]; then
          error "Missing required value: 'WORKING_SCRIPT'"
          prev="$arg"
          [ "$in_shell" -eq 1 ] && return || exit 1
        fi
        shift
        setarg "$1"
        if echo "$arg" | grep -q '^-' || [ -z "$arg" ]; then
          error "Missing required value: 'NEW_NAME'"
          [ "$in_shell" -eq 1 ] && return || exit 1
        fi
        __rename "$prev" "$arg"
        [ "$in_shell" -eq 1 ] && return || exit 0
        ;;
      -C | --config | config | cfg )
        shift
        setarg "$1"
        if echo "$1" | grep -q '^-' || [ -z "$1" ]; then
          error "Missing required value: 'RULE'"
          [ "$in_shell" -eq 1 ] && return || exit 1
        fi
        __config "$@"
        [ "$in_shell" -eq 1 ] && return || exit 0
        ;;
      -*l* | --list | list )
        shift
        setarg "$1"
        __list "$arg"
        [ "$in_shell" -eq 1 ] && return || exit 0
        ;;
      --interactive | sh | shell )
        in_shell=1
        __sh
        [ "$in_shell" -eq 1 ] && return || exit 0
        ;;
      --shopt | shopt )
        shift
        setarg "$1"
        __shopt "$arg"
        [ "$in_shell" -eq 1 ] && return || exit 0
        ;;
      -*V* | --verbose | verbose )
        VERBOSE=true
        ;;
      -\? | -h | --help | help )
        cat "$prgroot/help"
        [ "$in_shell" -eq 1 ] && return || exit 0
        ;;
      -v | --version | version )
        cat "$prgroot/version"
        [ "$in_shell" -eq 1 ] && return || exit 0
        ;;
      --update | update )
        __update
        [ "$in_shell" -eq 1 ] && return || exit 0
        ;;
      --reset-cfg | reset-cfg )
        verbose "Resetting BSM to default configuration..."
        cp -f "$repo/.bsm/.cfg" "$HOME/.bsm/.cfg" &&  log "BSM has been reset!" || error "Failed to reset defaults!"
        [ "$in_shell" -eq 1 ] && return || exit 0
        ;;
      --reset-shcfg | reset-sh )
        verbose "Resetting BSM Shell to default configuration..."
        cp -f "$repo/.bsm/sh.cfg" "$HOME/.bsm/sh.cfg" &&  log "BSM Shell has been reset!" || error "Failed to reset defaults!"
        [ "$in_shell" -eq 1 ] && return || exit 0
        ;;
      --uninstall | uninstall )
        __uninstall
        exit 0;;
      --dependencies | getdeps )
        __getdeps
        [ "$in_shell" -eq 1 ] && return || exit 0
        ;;
      * )
        # Catch-all
        if echo "$1" | grep -q '^-'; then
          cat "$prgroot/help" | head -1
          error "\"$1\" is not an argument!"
          [ "$in_shell" -eq 1 ] && return || exit 1
        else
          cat "$prgroot/help" | head -1
          error "\"$1\" is not a command!"
          [ "$in_shell" -eq 1 ] && return || exit 1
        fi
        ;;
    esac
  shift; done

  # Clear function vars
  unset arg
}

__sh() {
  # Load into alternate screen
  tput smcup
  # Load BSM Shell options
  hush_motd="$(grep "hush_login" "$prgroot/sh.cfg" | cut -d= -f2)"
  # Welcome message
  [ "$hush_motd" = "false" ] && printf "$(cat "$prgroot/motd.txt")\n\n"
  # Purposeful infinite loop
  while [ true ]; do
    printf "\e[1;36mbsm\e[0m> "
    read -r stdin
    if [ "$stdin" = "exit" ] || [ "$stdin" = "quit" ]; then
      break
    elif [ "$stdin" = "pass" ]; then
      continue
    elif echo "$stdin" | grep -q "pass"; then
      bash -c "$(echo "$stdin" | cut -d ' ' -f2-)"
    else
      __args "$stdin"
    fi
  done

  # Unload from alternate screen
  tput rmcup

  # Clear function vars
  unset hush_motd stdin
}

__shopt() {
  [ -z "$1" ] && { cat "$prgroot/sh.cfg"; exit 0; }
  # Inner write function
  rwrite() {
    verbose "Setting rule from $oldvalue to $newvalue"
    sed -i -e "s/$rule=$oldvalue/$rule=$newvalue/" "$shcfg"
    log "Updated rule $rule from $oldvalue to $newvalue!"
  }
  shcfg="$prgroot/sh.cfg"
  if echo "$1" | grep -q '='; then
    rule="$(echo "$1" | cut -d= -f1)"
    oldvalue="$(grep "$rule" "$shcfg" | cut -d= -f2)"
    newvalue="$(echo "$1" | cut -d= -f2)"
    newvalue="$(echo "$newvalue" | tr '[:upper:]' '[:lower:]')"
    # Check by type
    case "$rule" in
      # Booleans
      hush_login )
        if ! echo "$newvalue" | egrep -q '^(true|false)$'; then
          error "Value must be a boolean (true/false)!"
          return 1
        else
          rwrite
        fi
        ;;
      * )
        error "Not a shell option!"
        return 1
        ;;
    esac
  else
    [ "$1" = "RESET" ] && __args --reset-shcfg || {
      rule="$1"
      echo "$(grep "$rule" "$shcfg")"
    }
  fi

  # Clear the function
  unset rwrite rule oldvalue newvalue shcfg
}

__create() {
  # Check that the scripts folder was made
  [ ! -e "$scriptroot" ] && mkdir "$scriptroot"

  # Check if venv location is supplied
  envshebang="#!/usr/bin/env "
  env=""
  envpath=""

  # Inner type select func
  proctype() {
    name="$1"
    # Node
    if [[ "$name" =~ ".js" ]]; then
      if [[ -n "$env" ]]; then
        # [[ ! `command -v vem` ]] && echo -e "Must install Virtual Environment Manager to take advantage of Node Virtual Environments!\nRun \`git clone https://github.com/CodeKing710/vem; vem/install;\` to download and install VEM!" && exit
        # VEM is optional to be able to manage your envs
        # To allow reference, use the path to THE PARENT FOLDER of the node_modules folder that has the desired packages
        # If VEM is installed, it will list your envs and check if the name exists then use that path
        # Paths detected by the '/' that exists in each path
        if [[ -n "$(command -v vem)" ]]; then
          vemenv="$(vem js --path "$envpath" 2>/dev/null)"
          [[ -z "$vemenv" ]] && error "No VEM env with name $envpath!" && exit
          envpath="$vemenv"
        else
          # Assume path, bail upon no path
          [[ ! "$envpath" =~ '/' ]] && error "VEM must be installed to use names!\nIf this is a path, please prepend it with './' or use the absolute path!" && exit
        fi
        if [[ ! -e "$envpath" ]]; then
          error "Environment path doesn't exist!"
          error "$envpath"
          exit
        else
          # envshebang="#!$envpath/"
          envpath="$envpath/node_modules/"
          [[ $TERM_PROGRAM == 'mintty' ]] && envpath=$(cygpath -w "$envpath" | sed -e 's;\\;/;g;' | sed -e 's;/;//;g;' | sed -e 's;//;\\\\\\\\;g;') || envpath="$envpath"
          mkfile "${envshebang}node\n\n" "${name%.***}" "//" "const venv = '$envpath'\nconst getpkg = (loc) => {\n\t/**\n\t\tWith this being a venv,\n\t\tevery reference to a package that isn't directly in the project\n\t\tmust go through this wrapper\n\t\tto ensure node is looking in the right place.\n\n\t\tIf you are getting a package relative to your project,\n\t\tUSE REQUIRE!! Or use ESM import syntax\n\t**/\n\trequire(\`\${venv}\${loc}\`);\n}\n"
        fi
      else
        mkfile "${envshebang}node\n\n" "${name%.***}" "//"
      fi
    # Python
    elif [[ "$name" =~ ".py" ]]; then
      if [[ -n "$env" ]]; then
        if [[ -n "$(command -v vem)" ]]; then
          vemenv="$(vem py --path "$envpath" 2>/dev/null)"
          [[ -e "$vemenv/bin" ]] && vemenv="$vemenv/bin" || vemenv="$vemenv/Scripts"
          [[ -z "$vemenv" ]] && error "No VEM env with name $envpath!" && exit
          envpath="$vemenv"
        else
          # Assume path, bail upon no path
          [[ ! "$envpath" =~ '/' ]] && error "VEM must be installed to use names!\nIf this is a path, please prepend it with './' or use the absolute path!" && exit
        fi
        if [[ ! -e "$envpath" ]]; then
          error "Environment path doesn't exist!"
          error "$envpath"
          exit
        else
          envshebang="#!$envpath/"
          mkfile "${envshebang}python\n\n" "${name%.***}" "#"
        fi
      else
        mkfile "${envshebang}python\n\n" "${name%.***}" "#"
      fi
    # Ruby
    elif [[ "$name" =~ ".rb" ]]; then
      mkfile "${envshebang}ruby\n\n" "${name%.***}" "#"
    # LISP
    elif [[ "$name" =~ ".cl" ]]; then
      mkfile "${envshebang}-S sbcl --script\n\n" "${name%.***}" ";"
    # PowerShell
    elif [[ "$name" =~ ".ps1" ]]; then
      mkfile "${envshebang}powershell\n\n" "${name%.***}" "#"
    # Perl
    elif [[ "$name" =~ ".pl" ]]; then
      mkfile "${envshebang}perl\n\n" "${name%.***}" "#"
    # Bash
    elif [[ "$name" =~ ".sh" ]]; then
      mkfile "${envshebang}bash\n\n" "${name%.***}" "#"
    # Default script type
    else
      mkfile "${envshebang}$(echo "$defaulttype" | sed -e 's;lisp;-S sbcl --script;gi;')\n\n" "${name%.***}" "#"
    fi
  }
  # Inner file generator func
  mkfile() {
    # $1 is the shebang line, $2 is the file itself
    verbose "Writing data to script file..."
    verbose "Extra content: $4"

    scriptloc="${scriptroot}/${2}"
    printf "${1}${3} Script - ${2}\n${3} Purpose: XYZ\n\n$([[ -n "$4" ]] && echo "${4}")" > "${scriptloc}" && log "Successfully created script '${2}'!\n" || error "Failed to create script ${2} at ${scriptloc}!"
    # Make script executable to the user and the group
    chmod 775 "${scriptloc}"

    # Set the current working script (__cws) to the newly created script
    __cws="$2"
  }

  # Finishing the loop will hand back the arg list
  # This behavior is only necessity for args that accept
  # unlimited values that are then followed by more args
  until [[ "$1" =~ ^- || -z "$1" || "$1" =~ $([[ "$BASH_VERSION" =~ ^[0-3] ]] && echo $cmds || echo ${list[cmds]}) ]]; do
    [[ "$1" =~ ^(-e|--env|env)$ ]] && env=true && shift && envpath="$1" && shift
    name="$1"
    
    verbose "Script name: ${name%.***}"

    # Check for conflict of name
    if [ -e "$scriptroot/${name%.***}" ]; then
      printf "\e[1;31m[WARNING]\e[0m The script ${name%.***} already exists! Did you want to overwrite? [Y\\\\n] "
      read yn
      [[ "${yn,,}" =~ "y" ]] && proctype "$name" || echo "Keeping original script '${name%.***}'"
    else
      proctype "$name"
    fi
    env=""
    envpath=""
  shift; done; [[ -n "$@" ]] && __args "$@"
}

__open() {
  if [[ -n "$1" ]]; then # Arg passed
    __cws="$1" # Set
  elif [[ -z "$__cws" && -n "$1" ]]; then
    __cws="$1"
  fi

  [[ -n "$__cws" ]] && "$editor" "$scriptroot/$__cws" || error "No file to open!"
}

__remove() {
  # Loop until an arg is seen
  until [[ "$1" =~ ^- || "$1" == "" || "$1" =~ $([[ "$BASH_VERSION" =~ ^[0-3] ]] && echo $cmds || echo ${list[cmds]}) ]]; do
    name="$1"
    rm "$scriptroot/$name" 2>/dev/null && log "Successfully removed script '$name'" || error "Unable to remove script '$name'"
  shift; done; [[ -n "$@" ]] && __args "$@"
}

__list() {
  list="$(ls -p1 "$scriptroot" 2>/dev/null)"
  if [[ ! -e "$scriptroot" || "$list" == "" ]]; then
    log "No Scripts Created Yet!"
  else
    [[ "$1" =~ ^(-1|rows)$ ]] && printf "$list\n" || printf "$list\n" | column
  fi
}

# Accepted arg style: oldname>newname
__rename() {
  # Loop until arg or cmd is seen
  until [[ "$1" =~ ^- || "$1" == "" || "$1" =~ $([[ "$BASH_VERSION" =~ ^[0-3] ]] && echo $cmds || echo ${list[cmds]}) ]]; do
    old="$1"
    new="$2"
    shift # Ensure next arg in loop is not the new name
    if [ -n "$old" -a -n "$new" ]; then
      mv "$scriptroot/$old" "$scriptroot/$new" 2>/dev/null && log "Successfully renamed '$old' to '$new'!"
      __cws="$new"
    else
      error "Format incorrect! Format: OLD_NAME NEW_NAME"
    fi
  shift; done; [[ -n "$@" ]] && __args "$@"
}

# Variable arg style: rule rule=value
__config() {
  # Inner log function
  rwrite() {
    verbose "Setting rule from $oldvalue to $newvalue"
    sed -i -e "s/$rule=$oldvalue/$rule=$newvalue/" $cfg
    log "Updated rule $rule from $oldvalue to $newvalue!"
  }
  cfg="$prgroot/.cfg"
  until [[ "$1" =~ ^- || "$1" == "" || "$1" =~ $([[ "$BASH_VERSION" =~ ^[0-3] ]] && echo ${cmds/\|list/} || echo ${list[cmds]/\|list/}) ]]; do
    if [[ "$1" =~ '=' ]]; then
      rule="${1%%=*}"
      oldvalue="$(cat "$cfg" | grep "$rule" | cut -d= -f2)"
      newvalue="${1##*=}"
      newvalue="$(echo "$newvalue" | tr '[:upper:]' '[:lower:]')"
      # Check value lists for specific settings
      case "$rule" in
        autoupdate )
          # Bool rules
          if [[ ! "${newvalue}" =~ ^(true|false)$ ]]; then
            error "Value must be a boolean!"
            exit
          else
            rwrite
          fi
          ;;
        defaulttype )
          # Type rules
          if [[ ! "${newvalue}" =~ $([[ "$BASH_VERSION" =~ ^[0-3] ]] && echo $cfg_type || echo ${list[cfg_type]}) ]]; then
            error "Value must be Bash, Python, Ruby, LISP, Perl, or Node!"
            exit
          else
            rwrite
          fi
          ;;
        * )
          # Any other rules
          rwrite
          ;;
      esac
    elif [[ "$1" == 'list' ]]; then
      echo "Current Settings:"
      cat "$cfg"
      return
    elif [[ "$1" == 'RESET' ]]; then
      __args --reset-cfg
    fi
    log "Rule: `cat "$cfg" | grep "\b$1\b" || error "No Rule Found!"`"
  shift; done; [[ -n "$@" ]] && __args "$@"
}

__uninstall() {
  read -p "Are you sure you want to uninstall BSM? [Y\n] " yn
  yn="$(echo "$yn" | tr '[:upper:]' '[:lower:]')"
  if [[ "${yn}" =~ 'y' ]]; then
    log "Uninstalling BSM..."
    rm "$HOME/bin/bsm"
    rm -r "$HOME/.bsm"

    read -p "Did you want to remove the repo as well? [Y\n] " yn
    yn="$(echo "$yn" | tr '[:upper:]' '[:lower:]')"
    if [[ "${yn}" =~ 'y' ]]; then
      log "Removing repo..."
      rm -r "$repo"
    else
      log "Keeping the repo"
    fi
    log "Successfully removed BSM!"
  fi
}

# Testing phase
__getdeps() {
  [[ ! "$OSTYPE" =~ "linux" ]] && error "You must manually install the dependencies!" && return
  
  log "Retrieving BSM dependencies..."
  sudo apt-get install nodejs
  sudo apt-get install python
  sudo apt-get install ruby
  sudo apt-get install sbcl
}

__update() {
  verbose "Checking for updates..."
  if [[ `diff "$repo"/.bsm/.lib "$HOME"/.bsm/.lib` || `diff "$repo"/.bsm/version "$HOME"/.bsm/version` || `diff "$repo"/.bsm/help "$HOME"/.bsm/help` ]]; then 
    verbose "Updating BSM..."
    "$repo/install" &&  log "Successfully installed BSM!"
  else
    log "BSM up-to-date!"
  fi
}
