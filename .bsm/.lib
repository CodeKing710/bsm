#!/bin/bash

# BSM's Functions and Variables

# Vars
__cwd=`pwd`
__cws=""
prgroot="$HOME/.bsm"
scriptroot="$HOME/scripts"
editor=`cat $prgroot/.cfg | head -1 | cut -d '=' -f2`

# Funcs
__args() {
  # Process args
  # Exit means arg list is not passed
  # Return means arg list recursively passed
  while [[ $1 =~ '-' ]]; do
    case "$1" in
      -c | --create )
        shift
        __create $@
        return;;
      -o | --open )
        shift
        __open $1 # Can only open one file at a time so any more wouldn't make sense
        exit;;
      -r | --remove )
        shift
        __remove $@
        return;;
      -R | --rename )
        shift
        exit;;
      -C | --config )
        shift
        exit;;
      -l | --list )
        __list
        ;;
      -i | --interactive )
        __sh
        exit;;
      -\? | -h | --help )
        cat $prgroot/help
        exit;;
      -v | --version )
        cat $prgroot/version
        exit;;
      * ) # Catch-all
        cat $prgroot/help | head -1
        echo "\"$1\" is not an argument!"
        exit;;
    esac
  shift; done
}

__cmds() {
  while [[ "$1" != "" ]]; do
    local cmd="${1,}"
    shift
    case $cmd in
      create )
        if [[ "$1" == "" ]]; then
          echo "Missing required argument: 'NAME'"
        else
          sub="${1,}"
          shift
          name="$1"
          case $sub in
            ps | ps1 | powershell )
              __create -P $name
              ;;
            py | python )
              __create -p $name
              ;;
            pl | perl )
              __create -e $name
              ;;
            js | node )
              __create -n $name
              ;;
            rb | ruby )
              __create -r $name
              ;;
            cl | lisp )
              __create -l $name
              ;;
            sh | bash )
              __create -b $name
              ;;
            * )
              __create $sub
              ;;
          esac
        fi
        ;;
      open )
        name="$1"
        if [[ "$name" == "" ]]; then
          echo "Missing required argument: 'NAME'"
        else
          __open $name
        fi
        ;;
      # import )
      #   script="$1"
      #   if [[ "$script" == "" ]]; then
      #     echo "Missing required argument: 'SCRIPT'"
      #   else
      #     import_script $@
      #   fi
      #   ;;
      # export )
      #   script="$1"
      #   shift
      #   dest="$1"
      #   if [[ "$script" == "" ]]; then
      #     echo "Missing required argument: 'SCRIPT'"
      #   else
      #     if [[ "$dest" == "" ]]; then
      #       echo "Missing required argument: 'DESTINATION'"
      #     else
      #       export_script $script $dest
      #     fi
      #   fi
      #   ;;
      # link )
      #   script="$1"
      #   shift
      #   name="$1"
      #   if [[ "$script" == "" ]]; then
      #     echo "Missing required argument: 'SCRIPT'"
      #   else
      #     if [[ "$name" == "" ]]; then
      #       echo "Missing required argument: 'NAME'"
      #     else
      #       link_script $script $name
      #     fi
      #   fi
      #   ;;
      rename )
        name="$1"
        shift
        newname="$1"
        if [[ "$name" == "" ]]; then
          echo "Missing required argument: 'NAME'"
        else
          if [[ "$newname" == "" ]]; then
            echo "Missing required argument: 'NEW_NAME'"
          else
            __rename $name $newname
          fi
        fi
        ;;
      remove )
        name="$1"
        if [[ "$name" == "" ]]; then
          echo "Missing required argument: 'SCRIPT'"
        else
          __remove $@
        fi
        ;;
      config )
        rule="${1,}"
        shift
        value="${1,}"
        if [[ "$rule" == "" ]]; then
          echo "Missing required argument: 'RULE'"
        else
          if [[ "$value" == "" || "$value" == "config" ]]; then
            __config $rule
          else
            __config $rule $value
          fi
        fi
        ;;
      sh | shell )
        __sh
        ;;
      list )
        __list
        ;;
      version )
        __args -v
        ;;
      help )
        __args -h
        ;;
      * )
        echo "'$1': Command not found"
        ;;
    esac
  shift; done
}

__sh() {
  while true; do
    read -p "bsm> " stdin
    if [[ "${stdin,}" == "exit" || "${stdin,}" == "quit" ]]; then
      exit
    elif [[ "${stdin,}" == "pass" ]]; then
      continue
    elif [[ "${stdin,}" =~ "pass" ]]; then
      bash -c "$(echo "${stdin,}" | cut -d ' ' -f2-)"
    else
      __cmds "${stdin,}"
    fi
  done
}

__create() {
  # Check that the scripts folder was made
  [ ! -d $scriptroot ] && mkdir $scriptroot

  # Inner type select func
  proctype() {
    if [[ "$name" =~ ".js" ]]; then # Node
      mkfile "#!/bin/env\n\n" "${name%.***}"
    elif [[ "$name" =~ ".py" ]]; then # Python
      mkfile "#!/bin/env\n\n" "${name%.***}"
    elif [[ "$name" =~ ".rb" ]]; then # Ruby
      mkfile "#!/bin/env\n\n" "${name%.***}"
    elif [[ "$name" =~ ".cl" ]]; then # LISP
      mkfile "#!/bin/env\n\n" "${name%.***}"
    elif [[ "$name" =~ ".ps1" ]]; then # PowerShell
      mkfile "#!/bin/env\n\n" "${name%.***}"
    elif [[ "$name" =~ ".pl" ]]; then #Perl
      mkfile "#!/bin/env\n\n" "${name%.***}"
    else # Bash
      mkfile "#!/bin/bash\n\n" "${name%.***}"
    fi
  }
  # Inner file generator func
  mkfile() {
    # $1 is the shebang line, $2 is the file itself
    echo -e "$1# Script - $2\n# Purpose: XYZ\n" > ${scriptroot}/$2 && echo "Successfully created script at $scriptroot/$2!" || echo "Failed to create script $2 at $scriptroot/$2!"

    # Set the current working script (__cws) to the newly created script
    __cws=$2
  }

  # Finishing the loop will hand back the arg list
  # This behavior is only necessity for args that accept
  # unlimited values that are then followed by more args
  until [[ $1 =~ '-' || $1 == "" ]]; do
    local name=$1

    # Check for conflict of name
    if [ -e $scriptroot/$name ]; then
      read -p "The script $name already exists! Did you want to overwrite? [Y\n] " yn
      [[ "${yn,,}" =~ "y" ]] && proctype $name || echo "Keeping original script '$name'"
    else
      proctype $name
    fi
  shift; done; [ -n "$@" ] && __args $@
}

__open() {
  if [ -n "$1" ]; then # Arg passed
    __cws=$1 # Set
  elif [ -z "$__cws" -a -n "$1" ]; then
    __cws="$1"
  fi
  [ -n "$__cws" ] && $editor $scriptroot/$__cws || echo "No file to open!"
}

__remove() {
  until [[ $1 =~ '-' || $1 == "" ]]; do
    local name=$1
    rm $scriptroot/$name 2>/dev/null && echo "Successfully removed script '$name'" || echo "Unable to remove script '$name'"
  shift; done; [ -n "$@" ] && __args $@
}

# __rename() {}

__list() {
  local list=`ls -p1 $scriptroot | xargs -i echo "- {}"`
  if [[ ! -d $scriptroot || "$list" == "" ]]; then
    echo "No Scripts Created Yet!"
  else
    echo -e "Scripts:\n$list"
  fi
}

# __config() {}
