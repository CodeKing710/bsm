#!/bin/bash

# BSM's Functions and Variables

# Vars
__cwd=`pwd`
__cws=""
__cmds=( '' '' '' )
prgroot="$HOME/.bsm"
scriptroot="$HOME/scripts"

# Funcs
__loadcfg() {
  local cfg="$prgroot/.cfg"
  editor=`cat $cfg | grep 'editor' | cut -d '=' -f2`
  defaulttype=`cat $cfg | grep 'defaulttype' | cut -d '=' -f2`
}
# Config vars will be set via function in-case of needing reloaded
__loadcfg

__args() {
  # Process args
  # Exit means arg list is not passed
  # Return means arg list recursively passed
  while [[ $1 =~ '-' ]]; do
    case "$1" in
      -c | --create )
        shift
        [[ "$1" =~ '-' || -z "$1" ]] && echo "Missing required value: 'NAME'" && exit
        __create $@
        return;;
      -o | --open )
        shift
        # [[ "$1" =~ '-' || -z "$1" ]] && echo "Missing required value: 'NAME'" && exit
        __open $1 # Can only open one file at a time so any more wouldn't make sense
        exit;;
      -r | --remove )
        shift
        [[ "$1" =~ '-' || -z "$1" ]] && echo "Missing required value: 'NAME'" && exit
        __remove $@
        return;;
      -R | --rename )
        shift
        [[ "$1" =~ '-' || -z "$1" ]] && echo "Missing required value: 'REP_FRMT'" && exit
        __rename $@
        return;;
      -C | --config )
        shift
        [[ "$1" =~ '-' || -z "$1" ]] && echo "Missing required value: 'RULE'" && exit
        __config $@
        return;;
      -l | --list )
        __list
        ;;
      -i | --interactive )
        __sh
        exit;;
      -\? | -h | --help )
        cat $prgroot/help
        return;; # Because cmd mode references these options
      -v | --version )
        cat $prgroot/version
        return;; # Because cmd mode references these options
      --update )
        echo "Checking for updates..."
        if [[ `diff $(find $HOME -type d -name bsm)/.bsm/.lib $HOME/.bsm/.lib` || `diff $(find $HOME -type d -name bsm)/.bsm/version $HOME/.bsm/version` || `diff $(find $HOME -type d -name bsm)/.bsm/help $HOME/.bsm/help` ]]; then 
          echo "Updating BSM..."
          $(find $HOME -type d -name bsm)/install && echo "Successfully installed BSM!"
        else
          echo "BSM up-to-date!"
        fi
        exit;;
      --reset )
        echo "Resetting BSM to default configuration..."
        cp -rf $(find $HOME -type d -name bsm)/.bsm $HOME && echo "BSM has been reset!" || echo "Failed to reset defaults!"
        exit;;
      --uninstall )
        __uninstall
        exit;;
      --dependencies )
        __getdeps
        exit;;
      * ) # Catch-all
        cat $prgroot/help | head -1
        echo "\"$1\" is not an argument!"
        exit;;
    esac
  shift; done
}

__cmds() {
  while [[ "$1" != "" ]]; do
    case "${1,,}" in
      create )
        shift
        [[ "$1" =~ '-' || -z "$1" ]] && echo "Missing required value: 'NAME'" && exit
        __create $@
        ;;
      open )
        shift
        __open $1
        exit;;
      rename )
        shift
        [[ "$1" =~ '-' || -z "$1" ]] && echo "Missing required value: 'REP_FRMT'" && exit
        __rename $@
        return;;
      remove )
        shift
        [[ "$1" =~ '-' || -z "$1" ]] && echo "Missing required value: 'NAME'" && exit
        __remove $@
        return;;
      config )
        shift
        [[ "$1" =~ '-' || -z "$1" ]] && echo "Missing required value: 'RULE'" && exit
        __config $@
        return;;
      sh | shell )
        __sh
        ;;
      list )
        __list
        ;;
      version )
        __args -v
        ;;
      help )
        __args -h
        ;;
      update )
        __args --update
        ;;
      reset )
        __args --reset
        ;;
      uninstall )
        __uninstall
        exit;;
      getdeps )
        __getdeps
        ;;
      * )
        echo "'$1': Command not found"
        ;;
    esac
  shift; done
}

__sh() {
  while true; do
    read -p "bsm> " stdin
    if [[ "${stdin,}" == "exit" || "${stdin,}" == "quit" ]]; then
      break
    elif [[ "${stdin,}" == "pass" ]]; then
      continue
    elif [[ "${stdin,}" =~ "pass" ]]; then
      bash -c "$(echo "${stdin,}" | cut -d ' ' -f2-)"
    else
      __cmds "${stdin,}"
    fi
  done
}

__create() {
  # Check that the scripts folder was made
  [ ! -d $scriptroot ] && mkdir $scriptroot

  # Inner type select func
  proctype() {
    # Node
    if [[ "$name" =~ ".js" ]]; then
      mkfile "#!/bin/env node\n\n" "${name%.***}"
    # Python
    elif [[ "$name" =~ ".py" ]]; then
      mkfile "#!/bin/env python\n\n" "${name%.***}"
    # Ruby
    elif [[ "$name" =~ ".rb" ]]; then
      mkfile "#!/bin/env ruby\n\n" "${name%.***}"
    # LISP
    elif [[ "$name" =~ ".cl" ]]; then
      mkfile "#!/bin/env -S sbcl --script\n\n" "${name%.***}"
    # PowerShell
    elif [[ "$name" =~ ".ps1" ]]; then
      mkfile "#!/bin/env powershell\n\n" "${name%.***}"
    # Perl
    elif [[ "$name" =~ ".pl" ]]; then
      mkfile "#!/bin/perl\n\n" "${name%.***}"
    # Bash
    elif [[ "$name" =~ ".sh" ]]; then
      mkfile "#!/bin/bash\n\n" "${name%.***}"
    # Default script type
    else
      mkfile "#!/bin/env ${defaulttype/lisp/-S sbcl --script}\n\n" "${name%.***}"
    fi
  }
  # Inner file generator func
  mkfile() {
    # $1 is the shebang line, $2 is the file itself
    echo -e "$1# Script - $2\n# Purpose: XYZ\n" > "${scriptroot}/$2" && echo "Successfully created script at $scriptroot/$2!" || echo "Failed to create script $2 at $scriptroot/$2!"

    # Set the current working script (__cws) to the newly created script
    __cws="$2"
  }

  # Finishing the loop will hand back the arg list
  # This behavior is only necessity for args that accept
  # unlimited values that are then followed by more args
  until [[ $1 =~ '-' || $1 == "" ]]; do
    local name=$1

    # Check for conflict of name
    if [ -e $scriptroot/$name ]; then
      read -p "The script $name already exists! Did you want to overwrite? [Y\n] " yn
      [[ "${yn,,}" =~ "y" ]] && proctype $name || echo "Keeping original script '$name'"
    else
      proctype $name
    fi
  shift; done; [ -n "$@" ] && __args $@
}

__open() {
  if [ -n "$1" ]; then # Arg passed
    __cws=$1 # Set
  elif [ -z "$__cws" -a -n "$1" ]; then
    __cws="$1"
  fi

  [ -n "$__cws" ] && $editor $scriptroot/$__cws || echo "No file to open!"
}

__remove() {
  until [[ $1 =~ '-' || $1 == "" ]]; do
    local name=$1
    rm $scriptroot/$name 2>/dev/null && echo "Successfully removed script '$name'" || echo "Unable to remove script '$name'"
  shift; done; [ -n "$@" ] && __args $@
}

__list() {
  local list=`ls -p1 $scriptroot 2>/dev/null | xargs -i echo "- {}"`
  if [[ ! -d $scriptroot || "$list" == "" ]]; then
    echo "No Scripts Created Yet!"
  else
    echo -e "Scripts:\n$list"
  fi
}

# Accepted arg style: oldname>newname
__rename() {
  until [[ $1 =~ '-' || $1 == "" ]]; do
    local old=`echo "$1" | cut -d '>' -f1`
    local new=`echo "$1" | cut -d '>' -f2`
    if [ -n "$old" -a -n "$new" ]; then
      mv $scriptroot/$old $scriptroot/$new 2>/dev/null && echo "Successfully renamed '$old' to '$new'!"
      __cws="$new"
    else
      echo "Format incorrect! Format: OLD_NAME>NEW_NAME"
    fi
  shift; done; [ -n "$@" ] && __args $@
}

# Variable arg style: rule rule=value
__config() {
  local cfg="$prgroot/.cfg"
  until [[ $1 =~ '-' || $1 == "" ]]; do
    if [[ $1 =~ '=' ]]; then
      local rule="`echo "$1" | cut -d '=' -f1`"
      local oldvalue="`cat $cfg | grep "$rule" | cut -d '=' -f2`"
      local newvalue="`echo "$1" | cut -d '=' -f2`"
      sed -i -e "s/$rule=$oldvalue/$rule=$newvalue/" $cfg
      echo "Updated rule $rule from $oldvalue to $newvalue!"
    elif [[ $1 == 'list' ]]; then
      echo "Current Settings:"
      cat $cfg
      return
    elif [[ $1 == 'RESET' ]]; then
      __args --reset
    fi
    echo "Rule: `cat $cfg | grep "\b$1\b" || echo "No Rule Found!"`"
  shift; done; [ -n "$@" ] && __args $@
}

# NOT DONE YET (STUB)
__uninstall() {
  read -p "Are you sure you want to uninstall BSM? [Y\n] " yn
  if [[ "${yn,,}" =~ 'y' ]]; then
    echo "Uninstalling BSM..."

    read -p "Did you want to remove the repo as well? [Y\n] " yn
    if [[ "${yn,,}" =~ 'y' ]]; then
      echo "Removing repo..."
    else
      echo "Keeping the repo"
    fi
  fi
}

# NOT DONE YET (STUB)
__getdeps() {
  [ "$TERM_PROGRAM" = "mintty" ] && echo "You must manually install the dependencies for Git Bash!" && return
  
  echo "Retrieving BSM dependencies..."
}
