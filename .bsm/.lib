#!/bin/bash

# BSM's Functions and Variables

# Vars
__cwd=`pwd`
__cws=""
prgroot="$HOME/.bsm"
scriptroot="$HOME/scripts"
declare -A lists
lists[cmds]="^(create|open|rename|remove|config|sh|shell|list|version|help|update|reset|uninstall|getdeps)$"
lists[cfg_type]="bash python node ruby lisp perl"

# Output functions
error() { echo -e "\e[31m[ERROR]\e[0m $1" >&2; }

verbose() { [[ $VERBOSE ]] && echo -e "\e[32m[VERBOSE]\e[0m $1"; }

write() { echo -e "\e[36m[BSM]\e[0m $1"; }

# Funcs
__loadcfg() {
  local cfg="$prgroot/.cfg"
  editor=`cat $cfg | grep 'editor' | cut -d '=' -f2`
  defaulttype=`cat $cfg | grep 'defaulttype' | cut -d '=' -f2`
}
# Config vars will be set via function in-case of needing reloaded
__loadcfg

__args() {
  # Process args
  # Exit means arg list is not passed
  # Return means arg list recursively passed
  while [[ -n "$1" ]]; do
    case "$1" in
      -c | --create )
        shift
        [[ -z "$1" ]] && error "Missing required value: 'NAME'" && exit
        __create $@
        return;;
      -o | --open )
        shift
        # [[ "$1" =~ '-' || -z "$1" ]] && echo "Missing required value: 'NAME'" && exit
        __open $1 # Can only open one file at a time so any more wouldn't make sense
        exit;;
      -r | --remove )
        shift
        [[ "$1" =~ '-' || -z "$1" ]] && error "Missing required value: 'NAME'" && exit
        __remove $@
        return;;
      -R | --rename )
        shift
        [[ "$1" =~ '-' || -z "$1" ]] && error "Missing required value: 'REP_FRMT'" && exit
        __rename $@
        return;;
      -C | --config )
        shift
        [[ "$1" =~ '-' || -z "$1" ]] && error "Missing required value: 'RULE'" && exit
        __config $@
        return;;
      -l | --list )
        __list
        ;;
      -i | --interactive )
        __sh
        exit;;
      -V | --verbose )
        VERBOSE=true
        ;;
      -\? | -h | --help )
        cat $prgroot/help
        return;; # Because cmd mode references these options
      -v | --version )
        cat $prgroot/version
        return;; # Because cmd mode references these options
      --update )
        verbose "Checking for updates..."
        if [[ `diff $(find $HOME -type d -name bsm)/.bsm/.lib $HOME/.bsm/.lib` || `diff $(find $HOME -type d -name bsm)/.bsm/version $HOME/.bsm/version` || `diff $(find $HOME -type d -name bsm)/.bsm/help $HOME/.bsm/help` ]]; then 
          verbose "Updating BSM..."
          $(find $HOME -type d -name bsm)/install && write "Successfully installed BSM!"
        else
          write "BSM up-to-date!"
        fi
        exit;;
      --reset )
        verbose "Resetting BSM to default configuration..."
        cp -rf $(find $HOME -type d -name bsm)/.bsm $HOME && write "BSM has been reset!" || error "Failed to reset defaults!"
        exit;;
      --uninstall )
        __uninstall
        exit;;
      --dependencies )
        __getdeps
        exit;;
      * ) # Catch-all
        if [[ ! "$1" =~ '-' ]]; then
          __cmds "$@"
        else
          cat $prgroot/help | head -1
          error "\"$1\" is not an argument!"
          exit
        fi
        return;;
    esac
  shift; done
}

__cmds() {
  while [[ -n "$1" ]]; do
    case "${1,,}" in
      create )
        shift
        [[ -z "$1" ]] && error "Missing required value: 'NAME'" && exit
        __create $@
        return;;
      open )
        shift
        __open $1
        return;;
      rename )
        shift
        [[ "$1" =~ '-' || -z "$1" ]] && error "Missing required value: 'REP_FRMT'" && exit
        __rename $@
        return;;
      rm | remove )
        shift
        [[ "$1" =~ '-' || -z "$1" ]] && error "Missing required value: 'NAME'" && exit
        __remove $@
        return;;
      cfg | config )
        shift
        [[ "$1" =~ '-' || -z "$1" ]] && error "Missing required value: 'RULE'" && exit
        __config $@
        return;;
      sh | shell )
        __sh
        ;;
      list )
        __list
        ;;
      version )
        __args -v
        ;;
      help )
        __args -h
        ;;
      update )
        __args --update
        ;;
      reset )
        __args --reset
        ;;
      uninstall )
        __uninstall
        exit;;
      getdeps )
        __getdeps
        ;;
      * )
        if [[ "$1" =~ '-' ]]; then
          __args "$@"
        else
          cat $prgroot/help | head -1
          error "\"$1\" is not an command!"
          exit
        fi
        return;;
    esac
  shift; done
}

__sh() {
  while true; do
    read -p "bsm> " stdin
    if [[ "${stdin,}" == "exit" || "${stdin,}" == "quit" ]]; then
      break
    elif [[ "${stdin,}" == "pass" ]]; then
      continue
    elif [[ "${stdin,}" =~ "pass" ]]; then
      bash -c "$(echo "${stdin,}" | cut -d ' ' -f2-)"
    else
      __cmds "${stdin,}"
    fi
  done
}

__create() {
  # Check that the scripts folder was made
  [ ! -d $scriptroot ] && mkdir $scriptroot

  # Check if venv location is supplied
  local envshebang="#!/bin/env "
  local env=""
  local envpath=""

  # Inner type select func
  proctype() {
    local name="$1"
    # Node
    if [[ "$name" =~ ".js" ]]; then
      if [[ $env ]]; then
        # [[ ! `command -v vem` ]] && echo -e "Must install Virtual Environment Manager to take advantage of Node Virtual Environments!\nRun \`git clone https://github.com/CodeKing710/vem; vem/install;\` to download and install VEM!" && exit
        # VEM is optional to be able to manage your envs
        # To allow reference, use the path to THE PARENT FOLDER of the node_modules folder that has the desired packages
        # If VEM is installed, it will list your envs and check if the name exists then use that path
        # Paths detected by the '/' that exists in each path
        if [[ `command -v vem` ]]; then
          local vemenv=`vem js list | grep "$envpath"`
          [[ -z $vemenv ]] && error "No VEM env with name $envpath!" && exit
          envpath=$(vem js --path "$vemenv")
        else
          # Assume path, bail upon no path
          [[ ! "$envpath" =~ '/' ]] && error "VEM must be installed to use names!\nIf this is a path, please prepend it with './' or use the absolute path!" && exit
        fi
        if [[ ! -e "$envpath" ]]; then
          error "Environment path doesn't exist!"
          error "$envpath"
          exit
        else
          # envshebang="#!$envpath/"
          envpath="$envpath/node_modules/"
          [[ $TERM_PROGRAM == 'mintty' ]] && envpath=$(cygpath -w "$envpath" | sed -e 's;\\;/;g;' | sed -e 's;/;//;g;' | sed -e 's;//;\\\\\\\\;g;') || envpath="$envpath"
          mkfile "${envshebang}node\n\n" "${name%.***}" "//" "const venv = '$envpath'\nconst getpkg = (loc) => {\n\t/**\n\t\tWith this being a venv,\n\t\tevery reference to a package that isn't directly in the project\n\t\tmust go through this wrapper\n\t\tto ensure node is looking in the right place.\n\n\t\tIf you are getting a package relative to your project,\n\t\tUSE REQUIRE!! Or use ESM import syntax\n\t**/\n\trequire(\`\${venv}\${loc}\`);\n}\n"
        fi
      else
        mkfile "${envshebang}node\n\n" "${name%.***}" "//"
      fi
    # Python
    elif [[ "$name" =~ ".py" ]]; then
      if [[ $env ]]; then
        if [[ `command -v vem` ]]; then
          local vemenv=`vem py list | grep "$envpath"`
          [[ -z $vemenv ]] && error "No VEM env with name $envpath!" && exit
          envpath=$(vem py --path "$vemenv")
        else
          # Assume path, bail upon no path
          [[ ! "$envpath" =~ '/' ]] && error "VEM must be installed to use names!\nIf this is a path, please prepend it with './' or use the absolute path!" && exit
        fi
        if [[ ! -e "$envpath" ]]; then
          error "Environment path doesn't exist!"
          error "$envpath"
          exit
        else
          envshebang="#!$envpath/"
          mkfile "${envshebang}python\n\n" "${name%.***}" "#"
        fi
      fi
      mkfile "${envshebang}python\n\n" "${name%.***}" "#"
    # Ruby
    elif [[ "$name" =~ ".rb" ]]; then
      mkfile "${envshebang}ruby\n\n" "${name%.***}" "#"
    # LISP
    elif [[ "$name" =~ ".cl" ]]; then
      mkfile "${envshebang}-S sbcl --script\n\n" "${name%.***}" ";"
    # PowerShell
    elif [[ "$name" =~ ".ps1" ]]; then
      mkfile "${envshebang}powershell\n\n" "${name%.***}" "#"
    # Perl
    elif [[ "$name" =~ ".pl" ]]; then
      mkfile "${envshebang}perl\n\n" "${name%.***}" "#"
    # Bash
    elif [[ "$name" =~ ".sh" ]]; then
      mkfile "${envshebang}bash\n\n" "${name%.***}" "#"
    # Default script type
    else
      mkfile "${envshebang}${defaulttype/lisp/-S sbcl --script}\n\n" "${name%.***}" "#"
    fi
  }
  # Inner file generator func
  mkfile() {
    # $1 is the shebang line, $2 is the file itself
    verbose "Writing data to script file..."
    verbose "Extra content: $4"

    local scriptloc="${scriptroot}/${2}"
    echo -e "${1}${3} Script - ${2}\n${3} Purpose: XYZ\n\n`[ -n "$4" ] && echo ${4}`" > "${scriptloc}" && write "Successfully created script at ${scriptloc}!" || error "Failed to create script ${2} at ${scriptloc}!"

    # Set the current working script (__cws) to the newly created script
    __cws="$2"
  }

  # Finishing the loop will hand back the arg list
  # This behavior is only necessity for args that accept
  # unlimited values that are then followed by more args
  until [[ "$1" =~ '-' || -z "$1" || "$1" =~ ${lists[cmds]} ]]; do
    [[ "$1" =~ ^(-e|--env|env)$ ]] && env=true && shift && envpath="$1" && shift
    local name="$1"
    
    verbose "Script name: ${name%.***}"

    # Check for conflict of name
    if [ -e "$scriptroot/${name%.***}" ]; then
      echo -n "The script ${name%.***} already exists! Did you want to overwrite? [Y\n] "
      read yn
      [[ "${yn,,}" =~ "y" ]] && proctype "$name" || echo "Keeping original script '${name%.***}'"
    else
      proctype "$name"
    fi
    env=""
    envpath=""
  shift; done; [ -n "$@" ] && __args "$@"
}

__open() {
  if [ -n "$1" ]; then # Arg passed
    __cws=$1 # Set
  elif [ -z "$__cws" -a -n "$1" ]; then
    __cws="$1"
  fi

  [ -n "$__cws" ] && $editor $scriptroot/$__cws || error "No file to open!"
}

__remove() {
  until [[ $1 =~ '-' || $1 == "" || "$1" =~ ${lists[cmds]} ]]; do
    local name=$1
    rm $scriptroot/$name 2>/dev/null && write "Successfully removed script '$name'" || error "Unable to remove script '$name'"
  shift; done; [ -n "$@" ] && __args $@
}

__list() {
  local list=`ls -p1 $scriptroot 2>/dev/null | xargs -i echo "- {}"`
  if [[ ! -d $scriptroot || "$list" == "" ]]; then
    write "No Scripts Created Yet!"
  else
    echo -e "Scripts:\n$list"
  fi
}

# Accepted arg style: oldname>newname
__rename() {
  until [[ $1 =~ '-' || $1 == "" || "$1" =~ ${lists[cmds]} ]]; do
    local old=`echo "$1" | cut -d '>' -f1`
    local new=`echo "$1" | cut -d '>' -f2`
    if [ -n "$old" -a -n "$new" ]; then
      mv $scriptroot/$old $scriptroot/$new 2>/dev/null && write "Successfully renamed '$old' to '$new'!"
      __cws="$new"
    else
      error "Format incorrect! Format: OLD_NAME>NEW_NAME"
    fi
  shift; done; [ -n "$@" ] && __args $@
}

# Variable arg style: rule rule=value
__config() {
  local cfg="$prgroot/.cfg"
  until [[ $1 =~ '-' || $1 == "" || "$1" =~ ${lists[cmds]} ]]; do
    if [[ $1 =~ '=' ]]; then
      local rule="`echo "$1" | cut -d '=' -f1`"
      local oldvalue="`cat $cfg | grep "$rule" | cut -d '=' -f2`"
      local newvalue="`echo "$1" | cut -d '=' -f2`"
      # Check value lists for specific settings
      case "$rule" in
        autoupdate ) # Bool rules
          if [[ ! "$newvalue" =~ ^(true|false)$ ]]; then
            error "Value must be a boolean!"
            exit
          else
            verbose "Setting rule from $oldvalue to $newvalue"
            sed -i -e "s/$rule=$oldvalue/$rule=$newvalue/" $cfg
            write "Updated rule $rule from $oldvalue to $newvalue!"
          fi
          ;;
        defaulttype ) # Type rules
          local types=("${lists[cfg_type]}")
          for type in $types; do
            if [[ "$type" == "$newvalue" ]]; then
              verbose "Setting rule from $oldvalue to $newvalue"
              sed -i -e "s/$rule=$oldvalue/$rule=$newvalue/" $cfg
              write "Updated rule $rule from $oldvalue to $newvalue!"
              break
            fi
          done
          ;;
        * ) # Any other rules
          verbose "Setting rule from $oldvalue to $newvalue"
          sed -i -e "s/$rule=$oldvalue/$rule=$newvalue/" $cfg
          write "Updated rule $rule from $oldvalue to $newvalue!"
          ;;
      esac
    elif [[ $1 == 'list' ]]; then
      echo "Current Settings:"
      cat $cfg
      return
    elif [[ $1 == 'RESET' ]]; then
      __args --reset
    fi
    write "Rule: `cat $cfg | grep "\b$1\b" || error "No Rule Found!"`"
  shift; done; [ -n "$@" ] && __args $@
}

__uninstall() {
  read -p "Are you sure you want to uninstall BSM? [Y\n] " yn
  if [[ "${yn,,}" =~ 'y' ]]; then
    write "Uninstalling BSM..."
    rm $HOME/bin/bsm
    rm -r $HOME/.bsm

    read -p "Did you want to remove the repo as well? [Y\n] " yn
    if [[ "${yn,,}" =~ 'y' ]]; then
      write "Removing repo..."
      rm -r $repo
    else
      write "Keeping the repo"
    fi
    write "Successfully removed BSM!"
  fi
}

# Testing phase
__getdeps() {
  [ "$TERM_PROGRAM" = "mintty" ] && error "You must manually install the dependencies for Git Bash!" && return
  
  write "Retrieving BSM dependencies..."
  sudo apt-get install nodejs
  sudo apt-get install python
  sudo apt-get install ruby
  sudo apt-get install sbcl
}
